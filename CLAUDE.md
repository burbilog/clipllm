# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Important Guidelines

**DO NOT create git commits unless explicitly requested by the user.**

After making code changes, build the project to verify everything compiles, but wait for explicit user approval before committing.

## Project Overview

ClipLLM is a cross-platform LLM clipboard utility written in C++ using Qt6. It runs as a system tray service and allows users to process clipboard content (text and images) with AI prompts using global hotkeys.

**Key Statistics:** ~13,000+ lines of C++17 code across 3 modules (core, ui, models).

## Build Commands

### Linux Native Build

```bash
make build          # Build the project (creates build/, runs cmake, compiles)
make translations   # Update translation files using update-translations.sh
make clean          # Remove build directory
```

### Windows Cross-Compilation (from Linux)

**Requirements:** MXE (M Cross Environment) installed with Qt6

```bash
# Build for Windows (shared by default - recommended for installer)
make windows

# Build static binary (no DLL dependencies, larger file)
make windows MXE_BUILD_TYPE=static

# Deploy Windows build with DLLs and plugins
make windows-deploy

# Create Windows installer (requires NSIS)
make windows-installer

# Test with Wine
make test-windows-wine
```

**MXE Installation:**
```bash
# Clone MXE
git clone https://github.com/mxe/mxe.git ~/mxe
cd ~/mxe

# Build Qt6 for Windows (shared - recommended, ~1-2 hours)
make -j$(nproc) MXE_TARGETS='x86_64-w64-mingw32.shared' qt6

# Or build static (larger binaries, no DLLs needed)
make -j$(nproc) MXE_TARGETS='x86_64-w64-mingw32.static' qt6

# Optional: Build NSIS in MXE for creating installers
make -j$(nproc) MXE_TARGETS='x86_64-w64-mingw32.shared' nsis
```

**MXE Build Types:**
- `shared` (default) - Dynamic linking, requires DLL deployment, smaller exe, supports installer creation
- `static` - Static linking, standalone exe, larger file, installer creation problematic

### Standard Build (manual)

**Build directory:** `build/` in project root

```bash
cd build
cmake ..
make -j$(nproc)
```

### Install (Linux)
```bash
sudo make install
```

### Translation Management
```bash
make translations   # Update all translations from source code
./update-translations.sh    # Same as make translations
linguist translations/*.ts  # Edit translations in Qt Linguist
```

### Web Landing Page
```bash
make web            # Generate docs/index.html from docs/index.html.in
make web WEBSITE_VERSION=1.0.1  # Override version for website
```

**IMPORTANT:** The landing page at `docs/index.html` is **auto-generated**. Follow these rules:

1. **Source file:** Edit `docs/index.html.in` (the template)
2. **Generated file:** `docs/index.html` is created by `make web`
3. **Version:** The `@VERSION@` placeholder is replaced from `WEBSITE_VERSION` variable in Makefile
4. **Logo:** `art/clipllm_hires.png` is copied to `docs/clipllm_hires.png`
5. **Run `make web`** after:
   - Editing `docs/index.html.in`
   - Changing version in Makefile (`WEBSITE_VERSION`)
   - Updating `art/clipllm_hires.png`

**NEVER edit `docs/index.html` directly** — changes will be lost on next `make web`.

**The generated file contains a warning header:** `<!-- DO NOT EDIT THIS FILE DIRECTLY! ... -->`

**Note:** Both `docs/index.html.in` (template) and `docs/index.html` (generated) are committed to the repository for GitHub Pages. When editing, always modify `.in` and run `make web`.

**Version Separation:**
- `CMakeLists.txt` → version for **building** (development version, e.g., 1.0.1)
- `WEBSITE_VERSION` in Makefile → version for **website** (current release, e.g., 1.0.0)

This allows developing the next version while the website shows the current release. After release, update `WEBSITE_VERSION` in Makefile.

### Clean Build
```bash
make clean          # Remove all build directories (including Windows)
```

## Architecture

### Namespace Structure

The codebase is organized into three namespaces under `ClipLLM`:

- **`ClipLLM::Core`** - Core business logic (clipboard, LLM client, prompts, config, keychain, history)
- **`ClipLLM::Models`** - Data structures (Prompt, LLMConfig, HistoryEntry)
- **`ClipLLM::UI`** - User interface components (tray icon, dialogs, menus)

### Application Flow (src/core/app.h)

The `App` class (inherits `QApplication`) is the central controller that:

1. Enforces single-instance application
2. Initializes and manages lifecycle of all core components
3. Coordinates signal/slot communication between components
4. Manages translations/i18n
5. Provides access to UI dialogs (settings, history)

**Managed Components:**
- `ClipboardManager` - Monitors system clipboard for text/images
- `LLMClient` - HTTP client with SSE streaming support
- `PromptManager` - CRUD operations for prompts
- `ConfigManager` - QSettings wrapper for configuration
- `KeychainStore` - Platform keychain for API keys
- `HistoryManager` - Request history and statistics
- `GroupsManager` - Prompt group hierarchy management
- `ProviderKeyStore` - Provider API key storage
- `TrayIcon` - System tray integration

### Core Module Details

**ClipboardManager** (src/core/clipboardmanager.h)
- Uses Qt's `QApplication::clipboard()`
- Supports text, HTML, and image content
- Base64-encodes images for vision models

**LLMClient** (src/core/llmclient.h)
- State machine: Idle → Connecting → Streaming → Completed/Error
- Server-Sent Events (SSE) streaming with real-time parsing
- Supports OpenAI-compatible APIs with 7 pre-configured provider templates (OpenRouter, OpenAI, DeepSeek, Ollama, NanoGPT, llama.cpp, Custom)
- Provider-specific response parsing required for streaming

**PromptManager** (src/core/promptmanager.h)
- Loads prompts from `~/.config/ClipLLM/prompts.json` or bundled defaults
- Template format: `{clipboard}` placeholder in user prompt templates

**ConfigManager** (src/core/configmanager.h)
- Platform-agnostic storage via QSettings:
  - Linux: `~/.config/ClipLLM/ClipLLM.conf`
  - Windows: Registry `HKEY_CURRENT_USER\Software\ClipLLM`
  - macOS: `~/Library/Preferences/com.ClipLLM.plist`

**KeychainStore** (src/core/keychainstore.h)
- Credential storage using QSettings with XOR obfuscation
- TODO: Platform-specific keychain integration (libsecret/KWallet on Linux, Credential Manager on Windows, Keychain on macOS)

**GroupsManager** (src/core/groupsmanager.h)
- CRUD operations for prompt groups
- Tree structure with parent-child relationships
- Group metadata: name, description, icon, enabled state

**ProviderKeyStore** (src/core/providerkeystore.h)
- Provider API key storage with XOR obfuscation
- Per-profile key management
- TODO: Platform-specific keychain integration

### Data Models (src/models/)

- **Prompt**: `id`, `name`, `systemPrompt`, `userPromptTemplate`, `contentType` (Text/Image/Any), `model`, `icon`, `temperature`, `maxTokens`, `enabled`, `priority`, `overrideTemperature`, `metadata`
- **LLMConfig**: `provider` (enum), `apiKey`, `model`, `apiUrl`, `temperature`, `maxTokens`, `topP`, `stream`, `proxyUrl`, `timeoutSeconds`
- **HistoryEntry**: `id`, `promptId`, `timestamp`, `contentType`, input/output text, base64 images, token counts, duration, favorite, tags

### UI Components (src/ui/)

- **TrayIcon**: System tray with context menu, dynamic prompt generation
- **SettingsDialog**: 4-tab interface (General, LLM, Prompts, History)
- **ResultDialog**: Real-time streaming display with Markdown/Raw toggle
- **HotkeyEdit**: Custom widget for hotkey capture
- **HistoryDialog**: Searchable history viewer with Markdown/Raw preview and export
- **PromptEditorDialog**: Full UI for creating and editing prompts
- **PromptMenu**: Searchable menu with inline search and keyboard navigation
- **PromptPreviewDialog**: Preview prompt with clipboard content before execution
- **PromptConflictDialog**: Resolve conflicts when importing prompts
- **ImageViewDialog**: View clipboard images
- **GroupsDialog**: Manage prompt group hierarchy

## Debug Logging

ClipLLM has a built-in debug logging system that writes to `debug.log` in the configuration directory:
- Linux: `~/.config/ClipLLM/debug.log`
- Windows: Registry key path + `debug.log`
- macOS: `~/Library/Preferences/com.ClipLLM/debug.log`

### Debug Levels

- **Off** (0): Debug logging disabled (default)
- **Normal** (1): Basic debug messages - application lifecycle, errors, warnings
- **Trace** (2): Everything in Normal + full LLM request/response logging

### Usage in Code

**Include the header:**
```cpp
#include "core/debuglogger.h"
```

**Use the logging macros:**
```cpp
LOG_DEBUG(QStringLiteral("Processing item: %1").arg(item));
LOG_INFO(QStringLiteral("Operation completed successfully"));
LOG_WARNING(QStringLiteral("Unexpected value: %1").arg(value));
LOG_ERROR(QStringLiteral("Failed to load file: %1").arg(filename));

// Trace-level logging (only in Trace mode)
LOG_TRACE(QStringLiteral("Request body: %1").arg(body));
```

**Important guidelines:**
- Use `LOG_DEBUG` for general debugging information
- Use `LOG_INFO` for informational messages about normal operation
- Use `LOG_WARNING` for unexpected but recoverable situations
- Use `LOG_ERROR` for errors and failures
- Use `LOG_TRACE` for verbose debugging (full dumps, LLM request/response bodies)
- **Never use `qDebug()`, `qWarning()`, or `qCritical()` directly** - they go to stdout instead of the log file
- The macros automatically check if debug logging is enabled before writing (no performance impact when disabled)
- Settings changes (enable/disable, level switching) take effect **immediately** - no restart required

### Accessing DebugLogger Directly

For advanced usage, you can access the logger instance:
```cpp
auto* logger = ClipLLM::Core::DebugLogger::instance();
if (logger && logger->isEnabled()) {
    logger->setLevel(ClipLLM::Core::DebugLevel::Trace);
}
```

### Enabling Debug Logging

**Via UI:** Settings → General tab → Debug group → Check "Record debug messages"

**Or manually in config file:**
```ini
[debug]
enabled=true
level=2
```

## Configuration Files

- **Default Prompts**: `resources/config/prompts-default.json` (17 built-in prompts)
- **Qt Resources**: `resources/resources.qrc` - bundles prompts and icons into executable
- **Desktop Entry**: `resources/clipllm.desktop.in` - Linux application launcher

### Prompt Groups System

**GroupsManager** (src/core/groupsmanager.h)
- Hierarchical group organization for prompts
- Tree-based structure with parent-child relationships
- Groups can have icons and descriptions
- Built-in "Languages" group for translation prompts

**GroupsDialog** (src/ui/groupsdialog.h)
- Full UI for creating, editing, and deleting groups
- Tree view with drag-and-drop support
- Group icons and descriptions
- Assign prompts to groups via PromptEditorDialog

### Provider Profiles

**ProviderProfile** (src/models/providerprofile.h)
- Pre-configured templates for LLM providers
- 7 templates: OpenRouter, OpenAI, DeepSeek, Ollama, NanoGPT, llama.cpp, Custom
- Per-profile settings: apiUrl, model, temperature, maxTokens, stream, topP
- Profile enable/disable and default profile selection
- Cascade fallback: profile settings → global defaults

**ProviderKeyStore** (src/core/providerkeystore.h)
- Separate storage for provider API keys
- Per-profile key management
- Designed for future platform keychain integration

## Platform-Specific Notes

### Linux
- **Dependencies**: `qt6-base-dev`, `qt6-tools-dev`, `cmake`, `build-essential`
- **X11**: Full functionality including global hotkeys
- **Wayland**: System tray works, global hotkeys have limitations

### Windows (Cross-compiled from Linux)
- **Build Method**: MXE (M Cross Environment) cross-compilation
- **Build Types**: `shared` (default, requires DLLs) or `static` (standalone)
- **Toolchain**: `cmake/windows-x86_64-mingw.cmake` with MXE wrappers
- **Full Functionality**: All features supported including system tray and global hotkeys
- **Installer**: NSIS (Nullsoft Scriptable Install System) support via `make windows-installer`
- **See Also**: Windows Cross-Compilation section above for build details

### macOS
- Qt6 via Homebrew: `brew install qt@6`
- Full functionality supported

## Version Management

The project uses **two separate version numbers** to support development while maintaining the current release on the website:

### 1. Build Version (CMakeLists.txt)
Controls the actual application version in binaries.

```cmake
project(ClipLLM VERSION 1.0.1 LANGUAGES CXX)
```

When you change the version here:
- CMake automatically generates `build/src/core/version.h`
- All code can include `core/version.h` to access version macros:
  - `CLIPAI_VERSION_MAJOR`, `CLIPAI_VERSION_MINOR`, `CLIPAI_VERSION_PATCH`
  - `CLIPAI_VERSION_STR` - full version string (e.g., "1.0.1")
  - `ClipLLM::versionString()` - Qt function returning version QString

### 2. Website Version (Makefile)
Controls the version displayed on the landing page and download links.

```makefile
WEBSITE_VERSION := 1.0.0
```

**Workflow:**
- During development: `CMakeLists.txt = 1.0.1`, `WEBSITE_VERSION = 1.0.0` (current release)
- After release: Update `WEBSITE_VERSION` to match the new release version

**Example usage in code:**
```cpp
#include "core/version.h"

QString version = ClipLLM::versionString();  // "1.0.1"
```

**Never edit** `build/src/core/version.h` directly - it will be overwritten on rebuild.

## Release Management

When user requests a release, follow these steps:

### 1. Update version (if needed)
Edit `CMakeLists.txt` and update the version number:
```cmake
project(ClipLLM VERSION X.Y.Z LANGUAGES CXX)
```

### 2. Update website version in Makefile
Edit `Makefile` and set `WEBSITE_VERSION` to match the release version:
```makefile
WEBSITE_VERSION := X.Y.Z
```

### 3. Build all distribution packages
```bash
make linux-appimage    # Creates dist/clipllm-X.Y.Z-linux-x86_64.AppImage
make linux-tar         # Creates dist/clipllm-X.Y.Z-linux-x86_64.tar.gz
make windows-zip       # Creates dist/clipllm-X.Y.Z-windows-x86_64.zip
make windows-installer # Creates dist/ClipLLM-X.Y.Z-windows-x86_64-setup.exe
```

**Binary release artifacts (4 files from `dist/`):**
- `clipllm-X.Y.Z-linux-x86_64.AppImage` - Linux AppImage
- `clipllm-X.Y.Z-linux-x86_64.tar.gz` - Linux portable tarball
- `clipllm-X.Y.Z-windows-x86_64.zip` - Windows portable ZIP (with DLLs)
- `ClipLLM-X.Y.Z-windows-x86_64-setup.exe` - Windows installer

### 4. Update web page
```bash
make web               # Updates version in docs/index.html
```

### 5. Commit and push
```bash
git add -A
git commit -m "Release X.Y.Z"
git push
```

### 6. Create git tag (if not exists)
```bash
git tag -a vX.Y.Z -m "Version X.Y.Z"
git push origin vX.Y.Z
```

### 7. Create GitHub release
```bash
gh release create vX.Y.Z \
  dist/clipllm-X.Y.Z-linux-x86_64.AppImage \
  dist/clipllm-X.Y.Z-linux-x86_64.tar.gz \
  dist/clipllm-X.Y.Z-windows-x86_64.zip \
  dist/ClipLLM-X.Y.Z-windows-x86_64-setup.exe \
  -n "Release X.Y.Z: brief description"
```

**Notes:**
- Replace `X.Y.Z` with actual version number
- Use files from `dist/` directory
- `-n "..."` sets the release title/description (keep it brief)
- GitHub credentials are already configured
- Check if tag exists before creating: `git tag -l`

### 8. Start next development version (optional)
After release, bump the version in `CMakeLists.txt` for the next development cycle:
```cmake
project(ClipLLM VERSION X.Y.Z+1 LANGUAGES CXX)
```

**Important:** Do NOT update `WEBSITE_VERSION` in Makefile - it should stay at the current release version until the next release.

## Adding New Features

### Adding a New LLM Provider
1. Add to `LLMProvider` enum in `models/llmconfig.h`
2. Update `LLMConfig::createDefault()` and `availableModels()`
3. Add provider-specific streaming parsing in `llmclient.cpp`
4. Update Settings dialog provider dropdown

### Adding a New Prompt
1. Edit `~/.config/ClipLLM/prompts.json` directly, or
2. Use the Settings → Prompts tab with full prompt editor UI
3. Required fields: `id`, `name`, `system_prompt`, `user_prompt_template`, `content_type`, `enabled`
4. Optional: `priority` (higher = appears first in menu), `description`, `icon`

### Adding a New Language
1. Create `translations/clipllm_xx.ts`
2. Run `lupdate src/ -ts translations/clipllm_xx.ts`
3. Edit with Qt Linguist
4. Add to `TS_FILES` in CMakeLists.txt
5. Update Settings language dropdown


## Reference implementation

Directory ai-reader/ contains old reference implementation of this program. Read it
only if I reference previous, python incarnation of this program.

## Known Limitations

- **No CI/CD**: No GitHub Actions or other CI configuration

## Dependencies

- **Qt6**: Core, Widgets, Network, LinguistTools
- **Optional**: Qt6::Concurrent (for async operations)
- **Build**: CMake 3.16+, C++17 compiler
